# Streaming Result

goa makes it possible to define unidirectional server-side streaming where an
endpoint can receive a payload and return a stream of results.

This document describes how to define a method to return a stream of result
and what the code generator produces for the transport-independent and
transport-dependent code.

## Design

The [StreamingResult DSL](https://godoc.org/goa.design/goa/dsl#StreamingResult)
can be defined on a method to setup an endpoint that returns a stream of result.
`StreamingResult` DSL has the syntax similar to the `Result` DSL.

```go
var _ = Service("cellar", func() {
        Method("list", func() {
                // StoredBottle is sent to the client through a stream.
                StreamingResult(StoredBottle)
        })
})
```

The code generator produces the following stream interfaces for the `list`
endpoint in the service package.

```go
// Interface that the server must satisfy.
type ListServerStream interface {
  // Send sends StoredBottle through the stream.
  Send(*StoredBottle) error
  // Close closes the stream.
  Close() error
}

// Interface that the client must satisfy.
type ListClientStream interface {
  // Recv receives a StoredBottle from the stream.
  Recv() (*StoredBottle, error)
}
```

* `Send` method sends a result through the stream. It may return an error if
  a problem occurred when sending the result to the stream.
* `Close` method closes the stream. Closing a stream indicates that the server
  has sent all the results and is going to close the stream.
* `Recv` receives a result from the stream. It returns an `io.EOF` error if it
  has received all the results sent by the server.

The `List` method signature in the `Service` interface accepts the server
stream interface as one of the arguments. The generated goa client returns the
client stream interface.

The transport-dependent code implements the above mentioned server and client
stream interfaces using transport-specific streaming logic.

Here is an example service endpoint implementation that sends a stream of
`StoredBottle` and closes the stream after sending.

```go
// Lists lists the stored bottles.
func (s *cellarSvc) List(ctx context.Context, stream cellarsvc.ListServerStream) (err error) {
				bottles := loadStoredBottles()
  			for _, c := range bottles {
    						if err := stream.Send(c); err != nil {
      									return err
    						}
  			}
  			return stream.Close()
}
```

### Streaming in a HTTP Endpoint

Streaming is achieved in a HTTP endpoint using websockets. Goa uses
[gorilla websocket](https://godoc.org/github.com/gorilla/websocket) to
implement the server and client streaming interfaces.

The `goa http` package provides a websocket Upgrader and Dialer interface
and a websocket connection configurer function type which can be used to
customize a websocket connection obtained through the Upgrader and Dialer.

Here is an example to provide a custom websocket connection configuration
to the server and client streams.

```go
/* service main.go */

// Default upgrader generated by goa
//upgrader := &websocket.Upgrader{}
// Custom websocket upgrader
upgrader := &websocket.Upgrader {
				ReadBufferSize:  1024,
				WriteBufferSize: 1024,
}

// Websocket connection configurer
connConfigurer := func(conn *websocket.Conn) *websocket.Conn {
				conn.SetPingHandler(...)
				conn.SetPongHandler(...)
				conn.SetCloseHandler(...)
				return conn
}

cellarServer = cellarsvcsvr.New(cellarEndpoints, mux, dec, enc, eh, upgrader, connConfigurer)

/* client main.go */

// Default dialer generated by goa
//dialer = websocket.DefaultDialer
// Custom dialer
dialer = &websocket.Dialer {
				ReadBufferSize:  1024,
				WriteBufferSize: 1024,
}

endpoint, payload, err := cli.ParseEndpoint(
				scheme,
				host,
				doer,
				goahttp.RequestEncoder,
				goahttp.ResponseDecoder,
				debug,
				dialer,
				connConfigurer,
)
```

### Result Type with Multiple Views

If the method returns a result type with multiple views, a `SetView` method is
generated in both the interfaces with the following signature

```go
SetView(view string)
```

The application developer must call this method in the service endpoint
implementation before sending the data to the stream so that the result type is
rendered with appropriate view. If this method is never invoked the `default`
view is used to render the result type.

Here is an example that uses the view requested to render the stored bottles
before it is sent to the stream.

```go
// Lists lists the stored bottles.
func (s *cellarSvc) List(ctx context.Context, p *cellarsvc.ListPayload, stream cellarsvc.ListServerStream) (err error) {
				stream.SetView(p.View)
        bottles := loadStoredBottles()
        for _, c := range bottles {
                if err := stream.Send(c); err != nil {
                        return err
                }
        }
        return stream.Close()
}
```
