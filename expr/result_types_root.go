package expr

import (
	"goa.design/goa/v3/eval"
)

type (
	// ResultTypesRoot is a DSL root that records the result types
	// generated by the DSL.
	ResultTypesRoot []*ResultTypeExpr
)

// GeneratedResultTypes records the generated result types and is a DSL
// root evaluated after Root.
var GeneratedResultTypes = new(ResultTypesRoot)

// GeneratedResultType returns the generated result type expression with the given
// id, nil if there isn't one.
func GeneratedResultType(id string) *ResultTypeExpr {
	for _, rt := range *GeneratedResultTypes {
		if rt.Identifier == id {
			return rt
		}
	}
	return nil
}

// Append adds the given type to the generated result types if not already
// added. It returns the type that was added or already present.
func (r *ResultTypesRoot) Append(t *ResultTypeExpr) {
	*r = append(*r, t)
}

// EvalName is the name of the expression used by eval.
func (*ResultTypesRoot) EvalName() string {
	return "generated result types"
}

// WalkSets returns the generated result types for evaluation.
func (r *ResultTypesRoot) WalkSets(w eval.SetWalker) {
	set := make(eval.ExpressionSet, len(*r))
	for i, rt := range *r {
		set[i] = rt

		// This is a bit tricky: the DSL evaluation starts by running the expression DSLs.
		// In this first call to WalkSets we want to initialize the root expression
		// result types with the generated result types so that in future passes (prepare,
		// validate, etc.) the generated result types are walked when the root expression
		// is walked (see the root expression WalkSets implementation).
		Root.ResultTypes = append(Root.ResultTypes, rt)
	}
	w(set)
}

// DependsOn ensures that Root executes first.
func (*ResultTypesRoot) DependsOn() []eval.Root {
	return []eval.Root{Root}
}

// Packages returns the Go import path to this and the dsl packages.
func (*ResultTypesRoot) Packages() []string {
	return []string{
		"goa.design/goa/v3/expr",
		"goa.design/goa/v3/dsl",
	}
}
