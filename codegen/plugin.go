package codegen

import "goa.design/goa/eval"

type (
	// GenerateFunc makes it possible to modify the files generated by the
	// goa code generators and other plugins. A GenerateFunc accepts the Go
	// import path of the "gen" package, the design roots as well as the
	// currently generated files (produced initially by the goa generators
	// and potentially modified by previously run plugins) and returns a new
	// set of files.
	GenerateFunc func(genpkg string, roots []eval.Root, files []*File) ([]*File, error)

	// plugin is a plugin that has been registered with a given command.
	plugin struct {
		GenerateFunc
		root eval.Root
		cmd  string
	}
)

// plugins keeps track of the registered plugins.
var plugins []*plugin

// RegisterPlugin adds the plugin to the list of plugins to be invoked with the
// given command.
func RegisterPlugin(cmd string, root eval.Root, p GenerateFunc) {
	plugins = append(plugins, &plugin{p, root, cmd})
}

// RunPlugins executes the plugins registered with the given command in the order
// of dependencies.
func RunPlugins(cmd, genpkg string, roots []eval.Root, genfiles []*File) ([]*File, error) {
	for _, r := range roots {
		ps := findPlugins(r)
		if len(ps) == 0 {
			continue
		}
		for _, plugin := range ps {
			if plugin.cmd != cmd {
				continue
			}
			gs, err := plugin.GenerateFunc(genpkg, roots, genfiles)
			if err != nil {
				return nil, err
			}
			genfiles = gs
		}
	}
	return genfiles, nil
}

// findPlugins finds all registered plugins with the given Root expression.
func findPlugins(root eval.Root) []*plugin {
	ps := make([]*plugin, 0, len(plugins))
	for _, plugin := range plugins {
		if plugin.root == root {
			ps = append(ps, plugin)
		}
	}
	return ps
}
