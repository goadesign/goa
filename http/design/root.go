package design

import (
	"sort"
	"strings"

	"goa.design/goa/design"
	"goa.design/goa/eval"
)

var (
	// Root holds the root expression built on process initialization.
	Root = &RootExpr{Design: design.Root}

	// ErrorResult is the built-in result type for error responses.
	ErrorResult = design.ErrorResult

	// Empty represents empty values.
	Empty = design.Empty
)

type (
	// RootExpr is the data structure built by the top level HTTP DSL.
	RootExpr struct {
		// Design is the transport agnostic root expression.
		Design *design.RootExpr
		// Consumes lists the mime types supported by the API
		// controllers.
		Consumes []string
		// Produces lists the mime types generated by the API
		// controllers.
		Produces []string
		// HTTPServices contains the services created by the DSL.
		HTTPServices []*ServiceExpr
		// HTTPErrors lists the error HTTP responses.
		HTTPErrors []*ErrorExpr
	}
)

// Service returns the service with the given name if any.
func (r *RootExpr) Service(name string) *ServiceExpr {
	for _, res := range r.HTTPServices {
		if res.Name() == name {
			return res
		}
	}
	return nil
}

// ServiceFor creates a new or returns the existing service definition for the
// given service.
func (r *RootExpr) ServiceFor(s *design.ServiceExpr) *ServiceExpr {
	if res := r.Service(s.Name); res != nil {
		return res
	}
	res := &ServiceExpr{
		ServiceExpr: s,
	}
	r.HTTPServices = append(r.HTTPServices, res)
	return res
}

// EvalName is the expression name used by the evaluation engine to display
// error messages.
func (r *RootExpr) EvalName() string {
	return "API HTTP"
}

// WalkSets iterates through the service to finalize and validate them.
func (r *RootExpr) WalkSets(walk eval.SetWalker) {
	var (
		services  eval.ExpressionSet
		endpoints eval.ExpressionSet
		servers   eval.ExpressionSet
	)
	{
		services = make(eval.ExpressionSet, len(r.HTTPServices))
		sort.SliceStable(r.HTTPServices, func(i, j int) bool {
			if r.HTTPServices[j].ParentName == r.HTTPServices[i].Name() {
				return true
			}
			return false
		})
		for i, svc := range r.HTTPServices {
			services[i] = svc
			for _, e := range svc.HTTPEndpoints {
				endpoints = append(endpoints, e)
			}
			for _, s := range svc.FileServers {
				servers = append(servers, s)
			}
		}
	}
	walk(services)
	walk(endpoints)
	walk(servers)
}

// DependsOn is a no-op as the DSL runs when loaded.
func (r *RootExpr) DependsOn() []eval.Root { return nil }

// Packages returns the Go import path to this and the dsl packages.
func (r *RootExpr) Packages() []string {
	return []string{
		"goa.design/goa/http/design",
		"goa.design/goa/http/dsl",
	}
}

// Finalize initializes Consumes and Produces with defaults if not set.
func (r *RootExpr) Finalize() {
	if len(r.Consumes) == 0 {
		r.Consumes = []string{"application/json", "application/xml", "application/gob"}
	}
	if len(r.Produces) == 0 {
		r.Produces = []string{"application/json", "application/xml", "application/gob"}
	}
}

// NameMap returns the attribute and HTTP element name encoded in the given
// string. The encoding uses a simple "attribute:element" notation which allows
// to map header or body field names to underlying attributes. The second
// element of the encoding is optional in which case both the element and
// attribute have the same name.
func NameMap(encoded string) (string, string) {
	elems := strings.Split(encoded, ":")
	attName := elems[0]
	name := attName
	if len(elems) > 1 {
		name = elems[1]
	}
	return attName, name
}
